![UNAB-CBIB](https://github.com/microgenomics/Workshop-UTA/blob/master/images/logocbibhorizontal.png?raw=true)

## Microbial Genomics Lab

[Eduardo Castro-Nallar](https://github.com/ecastron) - [Jaime Alarcon](https://github.com/jaimealarcon)

[www.castrolab.org](http://www.castrolab.org)

---

###### Workshop_UTA - Día 1

# Introducción a la terminal, Bash, R/RStudio y Bioconductor

---

## Introducción a la Terminal

Hola! Bienvenidos al primer práctico de uso de la terminal y R, aquí aprenderás los comandos esenciales usados en la **terminal**, también conocida como **consola** o **shell**, que son la base en el manejo de cualquier proyecto que tenga bioinformática en él. Así que... manos a la obra!!

+ **Recordatorio: Nunca escribas variables, nombres de archivo o de carpetas con ESPACIOS o ACENTOS. Los espacios y acentos son enemigos naturales de las terminales.**

### ¿Qué es una Terminal?

|	<img src="https://github.com/microgenomics/Workshop-PUC/blob/master/images/terminal.png?raw=true" alt="alt text" width="150"> | <img src="https://github.com/microgenomics/Workshop-PUC/raw/master/images/terminal2.ico" alt="alt text" width="100">	| <img src="https://github.com/microgenomics/Workshop-PUC/blob/master/images/terminal3.jpg?raw=true" alt="alt text" width="200"> | <img src="https://github.com/microgenomics/Workshop-PUC/blob/master/images/terminal4.jpg?raw=true" alt="alt text" width="200"> |
|:-:|:-:|:-:|:-:|
|Esta es una terminal.| Esta también es una terminal.| Esto es la matrix, se hacen cosas parecidas en bioinformática, así que consideremos esta una terminal también.| Esto es un ramsomware, el virus que atacó a Movistar hace unos días, hecho para windows, esto **no** es una terminal.|

Una terminal es un intérprete de comandos fundamental en los sistemas operativos para la interacción con el usuario, ya que, se escriben comandos y acciones en él. Realizar acciones seguidas en una terminal también es considerado programar, en cierta forma podemos ser *hackers*. En este práctico solo nos concentraremos en las terminales basadas en Unix (Linux o Mac, los siento Windows, esta vez no).

### ¿Qué puedo hacer con la Terminal?

Prácticamente todo lo que hace un computador, con una terminal tu puedes dar ordenes y el computador lo hará, lo difícil es transmitir lo que realmente pensamos a la terminal.

### Primeras ordenes

Cuando se aprende un nuevo lenguaje de programación, lo tradicional es hacer que el computador nos diga "Hola Mundo" en dicho lenguaje de programación. Así que el primer paso abrir una terminal como esta:

![openterminal](https://github.com/microgenomics/Workshop-PUC/blob/master/images/openterminal.png?raw=true)
Ahora usaremos el comando `echo` para que la terminal nos diga lo que queremos, escribiremos: `echo "Hola Mundo"` y presionamos `enter`.

![hellow](https://github.com/microgenomics/Workshop-PUC/blob/master/images/hellow.png?raw=true)
En realidad podemos decirle al computador que nos diga cualquier cosa con el comando `echo`, recuerda que cada vez que ingresas un comando o acción debes presionar `enter`.

Ahora, escribe el comando `whoami` y presiona la tecla `enter` para enviar el comando a la shell/terminal. La salida del comando es la ID del usuario actual, es decir, nos muestra quién cree que somos:	$ whoami	jaimealarconA continuación, vamos a ver dónde estamos, usando el comando `pwd` (que significa "*print working directory*"). Nuestro directorio de trabajo actual es donde la terminel siempre cumplirá la orden, buscará archivos de entrada (*input*) y guardará los archivos de salida (*output*) generados, a menos que especifiquemos explícitamente otra cosa.	$ pwd	/Users/jaimealarconAhora, vamos a aprender el comando que nos permitirá ver el contenido de nuestro propio sistema de archivos. Podemos ver lo que hay en nuestro directorio de inicio ejecutando `ls`, que significa "*listing*":	$ ls	Applications Documents    Library      Music        Public	Desktop      Downloads    Movies       PicturesPara más información sobre cómo usar `ls` podemos escribir `man ls`. Man es el comando "manual" de Unix: imprime una descripción de un comando y sus opciones, y (si tienes suerte) proporciona algunos ejemplos de cómo usarlo.	$ man lsPara cambiar de ubicación dentro de la terminal usamos el comando `cd` seguido del nombre del directorio al cuál nos queremos dirigir. `cd` significa "*change directory*".	$ cd Desktop	# Nos movemos desde nuestro directorio de inicio a nuestro escritorio`cd` no imprime, pero si ejecutamos pwd podemos ver donde estamos ahora...	$ pwd
	/Users/jaimealarcon/DesktopPara ir al directorio anterior:	$ cd ..
	# para ir dos directorios antes...
	$ cd ../../
	# Entonces... estando en Desktop podemos ir al directorio Documents así...
	$ cd ../Documents#### Trabajando con archivos y directoriosVamos a crear un nuevo directorio llamado workshop usando el comando mkdir workshop (que no tiene output)$ mkdir workshopComo se puede adivinar por su nombre, mkdir significa "make directory". Dado que workshop es una ruta relativa (es decir, no tiene una barra inclinada principal), el nuevo directorio se crea en el directorio de trabajo actual$ ls -FVamos a cambiar nuestro directorio de trabajo workshop con cd, y a continuación, ejecutar un editor de texto llamado Nano para crear un archivo llamado draft.txt$ cd workshop$ nano draft.txtNano no deja ningún output en la pantalla después de que salga, pero ls ahora muestra que hemos creado un archivo llamado draft.txt:$ lsdraft.txtAhora ejecutemos el comando rm draft.txt:$ rm draft.txtEste comando elimina los archivos (rm es el término "remove"). Si ejecutamos ls de nuevo, el output está vacío una vez más, lo que nos dice que nuestro archivo se ha ido$ lsVamos a volver a crear ese archivo y luego subir un directorio a /Users/jaimealarcon/Desktop utilizando cd ..$ pwd/Users/jaimealarcon/Desktop/workshop$ nano draft.txt$ lsdraft.txt$ cd ..Si tratamos de eliminar todo el directorio de workshop utilizando la tesis rm, recibimos un mensaje de error:$ rm workshoprm: cannot remove `workshop': Is a directoryEsto sucede porque rm por defecto sólo funciona en archivos, no en directorios. Para realmente deshacerse de la tesis también debemos eliminar el archivo draft.txt. Podemos hacer esto con la opción recursiva para rm:$ rm -r workshopVamos a crear ese directorio y archivo una vez más. (Tenga en cuenta que esta vez estamos ejecutando nano con la ruta workshop/draft.txt, en lugar de ir al directorio de workshop y ejecutar nano en draft.txt allí.)$ pwd/Users/jaimealarcon/Desktop$ mkdir workshop$ nano workshop/draft.txt$ ls workshopdraft.txtdraft.txt No es un nombre particularmente informativo, así que cambiemos el nombre del archivo usando mv, que es abreviatura de "move"$ mv workoshop/draft.txt workshop/quotes.txtEl primer parámetro le dice a mv qué estamos moviendo, mientras que el segundo es a donde ir. En este caso, estamos trasladando workshop/draft.txt a workshop/quotes.txt, que tiene el mismo efecto que renombrar el archivo. Efectivamente, ls nos muestra que workshop ahora contiene un archivo llamado quotes.txt:$ ls workshopquotes.txtUtilizamos mv una vez más, pero esta vez usaremos el nombre de un directorio como el segundo parámetro para decirle a mv que queremos mantener el nombre de archivo, pero poner el archivo en algún lugar nuevo. (Es por eso que el comando se llama "mover".) $ mv quotes.txt /Users/jaimealarcon/Desktop El comando cp funciona muy parecido a mv, excepto que copia un archivo en lugar de moverlo. $ cp quotes.txt /Users/jaimealarcon/Desktop/workshopPodemos comprobar que hizo lo correcto usando ls Ahora vamos al directorio Mothur$ cd /Users/jaimealarcon/Desktop/Mothur$ ls MothurPodemos ejecutar el comando wc *.fastq.gzWc es el comando "word count": cuenta el número de líneas, palabras y caracteres en los archivos. El * que se encuentra en *.fastaq.qz  es una wildcard y coincide con cero o más caracteres, por lo que el shell convierte *.fastaq.qz en una lista de todos los archivos . fastaq.qz en el directorio actualLas wildcard o expresiones regulares, son símbolos que representan patrones, nos ayuda a aumentar nuestro umbral de match cuando queremos buscar algo.Si ejecutamos wc -l en lugar de wc, la salida sólo muestra el número de líneas por archivo:$ wc -l *.fastq.gz   43383 207_S191_L001_R1_001.fastq.gz   46905 207_S191_L001_R2_001.fastq.gz   47393 211_S194_L001_R1_001.fastq.gz   48886 211_S194_L001_R2_001.fastq.gz   43212 214_S197_L001_R1_001.fastq.gz   45679 214_S197_L001_R2_001.fastq.gz   31672 218_S201_L001_R1_001.fastq.gz   32385 218_S201_L001_R2_001.fastq.gz   35438 222_S205_L001_R1_001.fastq.gz   36301 222_S205_L001_R2_001.fastq.gz  411254 totalTambién podemos usar -w para obtener sólo el número de palabras, o -c para obtener sólo el número de caracteres.¿Cuál de estos archivos es el más corto? Es una pregunta fácil de responder cuando sólo hay 10 archivos, pero ¿qué pasa si hay 6000? Nuestro primer paso hacia una solución es ejecutar el comando:$ wc -l *.fastq.gz > lengths.txtEl símbolo mayor que,>, indica al shell que redirija la salida del comando a un archivo en lugar de imprimirlos a la pantalla. (Esto es por qué no hay salida de pantalla: todo lo que wc habría impreso ha ido en el archivo lengths.txt en su lugar.) El shell creará el archivo si no existe. Si el archivo existe, se sobrescribirá en silencio, lo que puede conducir a la pérdida de datos y, por lo tanto, requiere cierta precaución. Ls lengths.txt confirma que el archivo existe:$ ls lengths.txtlengths.txtAhora podemos enviar el contenido de lengths.txt a la pantalla usando cat lengths.txt cat significa "concatenar": imprime el contenido de los archivos uno tras otro. Sólo hay un archivo en este caso, por lo que cat sólo nos muestra lo que contiene:$ cat lengths.txt     43383 207_S191_L001_R1_001.fastq.gz   46905 207_S191_L001_R2_001.fastq.gz   47393 211_S194_L001_R1_001.fastq.gz   48886 211_S194_L001_R2_001.fastq.gz   43212 214_S197_L001_R1_001.fastq.gz   45679 214_S197_L001_R2_001.fastq.gz   31672 218_S201_L001_R1_001.fastq.gz   32385 218_S201_L001_R2_001.fastq.gz   35438 222_S205_L001_R1_001.fastq.gz   36301 222_S205_L001_R2_001.fastq.gz  411254 totalAhora vamos a usar el comando sort para ordenar su contenido. También usaremos el indicador -n para especificar que el orden es numérico en lugar de alfabético. Esto no cambia el archivo; En su lugar, envía el resultado ordenado a la pantalla:$ sort -n lengths.txt   31672 218_S201_L001_R1_001.fastq.gz   32385 218_S201_L001_R2_001.fastq.gz   35438 222_S205_L001_R1_001.fastq.gz   36301 222_S205_L001_R2_001.fastq.gz   43212 214_S197_L001_R1_001.fastq.gz   43383 207_S191_L001_R1_001.fastq.gz   45679 214_S197_L001_R2_001.fastq.gz   46905 207_S191_L001_R2_001.fastq.gz   47393 211_S194_L001_R1_001.fastq.gz   48886 211_S194_L001_R2_001.fastq.gz  411254 totalPodemos poner la lista ordenada de líneas en otro archivo temporal llamado sorted-lengths.txt poniendo > sorted-lengths.txt después del comando, tal como usamos > lengths.txt para poner la salida de wc en lengths.txt. Una vez que lo hayamos hecho, podemos ejecutar otro comando llamado head para obtener las primeras líneas en ordenadas-lengths.txt:$ sort -n lengths.txt > sorted-lengths.txt$ head -n 1 sorted-lengths.txtUsando el parámetro -n 1 con head le dice que sólo queremos la primera línea del archivo; -n 20 obtendría los primeros 20, y así sucesivamente. Dado que ordenado-lengths.txt contiene las longitudes de nuestros archivos ordenados de menor a mayor, la salida de head debe ser el archivo con menos líneas.31672 218_S201_L001_R1_001.fastq.gzSi crees que esto es confuso, estás en buena compañía: incluso una vez que entiendas lo que hace wc, sort, y head, todos esos archivos intermedios hacen difícil seguir lo que está pasando. Podemos hacerla más fácil de entender corriendo sort  y head juntos:$ sort -n lengths.txt | head -n 131672 218_S201_L001_R1_001.fastq.gzLa barra vertical, |, entre los dos comandos se denomina pipe. Le dice a la shell que queremos usar la salida del comando a la izquierda como entrada al comando de la derecha. El ordenador puede crear un archivo temporal si es necesario, o copiar datos de un programa a otro en la memoria, o cualquier otra cosa; No tenemos que saber o preocupar.$ wc -l *.fastq.gz | sort -n   31672 218_S201_L001_R1_001.fastq.gz   32385 218_S201_L001_R2_001.fastq.gz   35438 222_S205_L001_R1_001.fastq.gz   36301 222_S205_L001_R2_001.fastq.gz   43212 214_S197_L001_R1_001.fastq.gz   43383 207_S191_L001_R1_001.fastq.gz   45679 214_S197_L001_R2_001.fastq.gz   46905 207_S191_L001_R2_001.fastq.gz   47393 211_S194_L001_R1_001.fastq.gz   48886 211_S194_L001_R2_001.fastq.gz  411254 totalY ahora enviamos la salida de este pipe a través de otra pipe, a head para que el pipeline completo se convierta en:$ wc -l *.fastq.gz | sort -n | head -n 131672 218_S201_L001_R1_001.fastq.gz$ cd /Users/jaimealarcon/DesktopCuál es la diferencia entre:$ echo hello > testfile01.txty $ echo hello >> testfile02.txtSugerencia: Intente ejecutar cada comando dos veces seguidas y luego examinar los archivos de salida.LOOPSSi queremos copiar nuestros archivos fastq.gz para futuros análisis y agregarle el prefijo backup-$ cd Mothur $ cp *.fastq.gz backup-*.fastq.gzcp: target `backup-*.fastq.gz' is not a directoryEste problema surge cuando cp recibe más de dos entradas. Cuando esto sucede, espera que la última entrada sea un directorio donde pueda copiar todos los archivos que pasó. Dado que no hay ningún directorio llamado backup- *.fastq.gz en el directorio Mothur obtendremos un error.En su lugar, podemos usar un Loop para hacer alguna operación una vez para cada cosa en una lista. Aquí hay un ejemplo sencillofor filename in *.fastq.gzdo    cp $filename backup-$filename doneCuando el shell ve la palabra clave para, sabe repetir un comando (o grupo de comandos) una vez para cada cosa en una lista. Para cada iteración, el nombre de cada cosa se asigna secuencialmente a la variable y los comandos dentro del bucle se ejecutan antes de pasar a lo siguiente en la lista. Dentro del bucle, pedimos el valor de la variable poniendo $ delante de él. El $ le dice al intérprete de shell que trate la variable como un nombre de variable y que sustituya su valor en su lugar, en lugar de tratarlo como texto o como un comando externo.Encontrando cosasDe la misma manera que muchos de nosotros ahora usamos "Google" como un verbo que significa "para encontrar", los programadores de Unix a menudo usan la palabra "grep". "Grep" es una contracción de "global / regular expression / print", una secuencia común de operaciones en los primeros editores de texto de Unix. También es el nombre de un programa de línea de comandos muy útil.$ cd /Users/jaimealarcon/Desktop$ more taxonomia.txtGrep encuentra e imprime líneas en archivos que coinciden con un patrón. Para nuestros ejemplos, usaremos un archivo que contiene la taxonomía de 567 OTUs, buscando si encontramos el genero Pelomonas$ grep Pelomonas taxonomia.txt {"id":"Otu0006", "metadata":{"taxonomy":["Bacteria", "Proteobacteria", "Betaproteobacteria", "Burkholderiales", "Comamonadaceae", "Pelomonas"], "bootstrap":[100, 100, 100, 100, 100, 99]}},$ grep Pseudomonadaceae taxonomia.txt >> cuenta_pesudomo.txtDe esta manera con cw podemos contar cuentas encontramos en el archivo$ wc -l cuenta_pesudomo.txt8 cuenta_pesudomo.txt

